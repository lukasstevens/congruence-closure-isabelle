% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Introduction}\label{chapter:introduction}

Isabelle is an interactive theorem prover, with which it is possible to formalize mathematical formulas and proofs \cite{isabelle}. A common use case for it is the verification of algorithms.
It provides different types of logic, the most used one being Higher-Order Logic (HOL).

This thesis describes the implementation in Isabelle/HOL of algorithms that find the congruence closure of a set of equations. We consider equations containing constant symbols and function symbols. In the following, $a$, $b$, $c$ and $d$ will denote constants and $f$ and $F$ functions.
We consider only uninterpreted functions, that is we only know how many arguments the function takes, but not any other property of the functions.
A constant or a function applied to constants, e.g., $f(a, b)$, is called a \emph{term} and an equality between two terms, e.g., $f(a, b) = c$, is called an \emph{equation}.

Congruence closure is used in automated theorem proving in order to determine whether an equation is implied by a given set of equations.
Isabelle itself uses automated theorem strategies to solve current proof goals.
Therefore, the code of this thesis can be used as a basis for a new automated proof strategy in Isabelle.

In this thesis we will first introduce the union-find algorithm, which maintains the congruence closure of equations containing only constants, e.g. $a = b$. When we only consider constants, the congruence closure is also called equivalence closure. The equivalence closure of a relation is the smallest superset of the relation that is reflexive, symmetric and transitive. We denote that $a$ is in relation with $b$ by writing $a = b$. For example, the equivalence closure of $a = b$ and $b = c$ contains $a = c$.

Then, we consider an algorithm which maintains the congruence closure of equations containing also function symbols. The congruence closure of a set of equations satisfies, in addition to reflexivity, symmetry and transitivity, also monotonicity, i.e., $f(x_1, ... ,x_n) = f(y_1, ... ,y_n)$ if $x_i = y_i$ $\forall i \in [1..n]$ \cite{Nieuwenhuis}.
For example, the congruence closure of $f(a,b) = c$, $f(d,b) = e$ and $a = d$ contains the equation $c = e$. Several approaches to solve this problem have been described \cite{congruenceclosure-og2,congruenceclosure-og,congruenceclosure-og3,Nieuwenhuis}.
They differ in their runtime and application area.
Most implementations of congruence closure are based on the union-find algorithm. Dating back to 1964 \cite{unionfind-og}, the union-find algorithm is nowadays the most widely used algorithm for maintaining the equivalence closure of a set, due to its simplicity and almost constant runtime \cite{Tarjan}.

The congruence closure algorithm allows us to compute if an equation is implied by a given set of equations, therefore it is used in decision procedures such as satisfiability modulo theories (SMT) solvers \cite{z3}.
In these settings it is also required to understand which subset of the given equations is responsible for the congruence. For this reason, we also implement an \emph{explain} operation, which returns the set of input equations that caused the congruence.
This can be used by an external program in order to generate a certificate of the congruence and verify that it is in fact contained in the congruence closure of the input equations.
Nieuwenhuis and Oliveras have presented an efficient version of the congruence closure algorithm and two versions of the union-find algorithm, each with their own \emph{explain} operation. Their conference paper \cite{Nieuwenhuis} was later extended, see \cite{Nieuwenhuis2}.
We will call the \emph{explain} operation of the union-find algorithm \emph{explain}, and the one for congruence closure \emph{cc\_explain}.

The descriptions of the algorithms contain informal proofs, but the algorithms can be verified by an interactive theorem prover in order to strengthen our confidence in their correctness. In this thesis we will implement the algorithms of the paper by Nieuwenhuis et al. \cite{Nieuwenhuis} and prove their correctness in the theorem prover Isabelle/HOL.
Our implementation is based on the union-find formalization by Lammich \cite{unionfind-isabelle} in Isabelle/HOL. We implement three algorithms: the \emph{explain} operation for union-find, the congruence closure algorithm and the \emph{cc\_explain} operation for congruence closure.

To my knowledge, this thesis presents the first verified formalization of these algorithms in Isabelle/HOL. Given that the focus of this thesis is on the verification of the algorithms, a few optimizations are left out of the implementation, such as path compression for union-find.

\section{Outline}
This thesis is organized as follows: Chapter 2 gives a brief overview of the notation used by Isabelle and discusses some related work.

In Chapter 3 the union-find implementation by Lammich \cite{unionfind-isabelle} is described and the \emph{explain} operation for union-find is presented together with its correctness and termination proofs.

Chapter 4 looks at the congruence closure implementation and shows that it is correct and that it terminates. It also describes the \emph{cc\_explain} operation for congruence closure with its termination proof. The correctness proof is not part of this thesis. However, a proposed outline of the proof is presented.

The last chapter summarizes the results and gives an outlook on the possible future work.
The Isabelle code of this thesis is available on GitHub\footnote{\url{https://github.com/reb-ddm/congruence-closure-isabelle}}.
The code also contains the examples of this thesis in the files \lstinline|Examples_Thesis.thy| and \lstinline|CC_Examples_Thesis.thy|.

