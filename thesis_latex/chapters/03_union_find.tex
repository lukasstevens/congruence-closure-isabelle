% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Union-Find with Explain Operation}\label{chapter:union_find}

\section{Union-Find Algorithm}

In this thesis, we will use lists to model the union-find forest, where at each index $i$ the list contains the parent $l!i$ of the element $i$ in the forest. The theory ``Union\_Find'' also uses this representation.

If $i$ does not have a parent, e.g. it is a root, then the list contains the element $i$ itself at the index $i$, e.g. $l!i = i$.

\section{Union-Find in Isabelle}

The union find algorithm was already formalized in Isabelle, and the code can be found in the ``Archive of Formal Proofs'' (AFP)\cite{afp}.

For example the following is the definition of the $find$ operation from the Theory ``Union\_Find''\cite{Sep}. It is called \lstinline{rep_of}, because it finds the representative of an element in the union-find forest.

The domain of \lstinline{rep_of} is used in the theory ``Union\_Find'' to define the following invariant for valid union-find lists. \cite{Sep}.

\begin{lstlisting}
definition
  "ufa_invar l ≡ ∀i<length l. rep_of_dom (l,i) ∧ l!i<length l"
\end{lstlisting}

\section{Union-Find Data Structure}
\label{section:uf-data}

The section below describes the implementation of the modified Union Find data structure, as well as the $Explain$ operation and its correctness proof, as described in \cite{Nieuwenhuis}.

The data structure for the Union, Find and Explain operations consists of the following three lists:

\begin{itemize}
	\item \lstinline{uf_list}: This is the usual union-find list, which contains the parent node of each element in the forest data structure. It is the one described in Section \ref{chapter:preliminaries}.

	\item \lstinline{unions}: This list simply contains all the pairs of input elements in chronological order.

	\item \lstinline{au}: This is the \emph{associated unions} list, it contains for each edge in the union-find forest a label with the union that corresponds to this edge. Similarly to the \lstinline{uf_list}, it is indexed by the element, and for each element $e$ which has a parent in the \lstinline{uf_list}, \lstinline{au} contains the input equation which caused the creation of this edge between $e$ and its parent. The equations are represented as indexes in the \lstinline{unions} list. The type of the entries is \lstinline{nat option}, so that for elements without a parent, the \lstinline{au} entry is \lstinline{None}.
\end{itemize}

\begin{exmp}\label{empty_ufe}
For a union-find algorithm with 4 variables, the initial empty union find looks as follows:
\begin{lstlisting}
&$\llparenthesis$&uf_list = [0, 1, 2, 3], unions = [], au = [None, None, None, None]&$\rrparenthesis$&
\end{lstlisting}
Each element is its own parent in the \lstinline{uf_list}, which means that it is a root, the \lstinline{unions} list is empty because no unions were made yet, and there are no edges in the tree, therefore there are no labels in \lstinline{au}.
\end{exmp}

In order to reason about paths in the union-find forest, we define the following \lstinline{path} predicate.

\begin{lstlisting}
inductive path :: "nat list &$\Rightarrow$& nat &$\Rightarrow$& nat list &$\Rightarrow$& nat &$\Rightarrow$& bool" where
single: "n < length l ⟹ path l n [n] n" |
step: "r < length l ⟹ l ! u = r ⟹ l ! u ≠ u ⟹ path l u p v ⟹ path l r (r # p) v"
\end{lstlisting}

\lstinline{path l r p v} defines a path from $r$ to $v$, where $r$ is an ancestor of $v$, which means that it is closer to the root, and $p$ contains all the nodes visited on the path from $r$ to $v$. This definition proved to be very useful for many proofs, as will become clearer later in this thesis.

The theory \lstinline{Path} contains many lemmas about paths, including lemmas about concatenation of adjacent paths, and splitting of one path into two subpaths, and that the length of a path is at least 1, as well as others, many of which could be proven by rule induction on \lstinline{path}. The most interesting and useful lemma was about the unicity of paths between two nodes:

\begin{lstlisting}
theorem path_unique: "ufa_invar l ⟹ path l u p1 v ⟹ path l u p2 v ⟹ p1 = p2"
\end{lstlisting}

\begin{proof}
The lemma is proven by induction on the length of $p1$.

For the base case we assume that the length of $p1$ is 1. There is only one node in the path, therefore $v = u$. Then I proved a lemma which showed that if the \lstinline{ufa_invar} holds, each path from $v$ to $v$ has length 1, or, in other words, there are no cycles in the graph. For this I showed that if there was a cycle, the function \lstinline{rep_of} would not terminate, because there would be an infinite loop.

For the induction step, we assume that the length of $p1$ is greater than 1. Therefore, we can remove the last node from $p1$ and the last node from $p2$ to get two paths from $u$ to the parent of $v$, where the first one is shorter that $p1$, and we can apply the induction hypothesis, which tells us that the two paths are equal. Adding the node $v$ to those two paths gives us back the original paths $p1$ and $p2$, therefore we conclude that $p1 = p2$.
\end{proof}

\section{Implementation}

\subsection{Union}

The \emph{union} operation was already implemented for the \lstinline{uf_list} in the theory \lstinline{Union_Find} \cite{Sep} (chapter 18, Union-Find Data-Structure), it only needed to be extended in order to appropiately update the other two lists:

The algorithm only modifies the data structure if the parameters are not already in the same equivalence class.
The union find tree is modified with the \lstinline{ufa_union} from the theory \lstinline{Union_Find}\cite{Sep}.
The current union $(x, y)$ is added at the end of the \lstinline{unions} list.
\lstinline{au} is updated such that the new edge between \lstinline{rep_of l x} and \lstinline{rep_of l y} is labeled with the last index of \lstinline{unions}, which contains the current pair of elements $(x, y)$.

\begin{lstlisting}
fun ufe_union :: "ufe_data_structure ⇒ nat ⇒ nat ⇒ ufe_data_structure"
  where
    "ufe_union ⦇uf_list = l, unions = u, au = a⦈ x y = (
if (rep_of l x ≠ rep_of l y) then
    ⦇uf_list = ufa_union l x y,
     unions = u @ [(x,y)],
     au = a[rep_of l x := Some (length u)]⦈
else ⦇uf_list = l, unions = u, au = a⦈)"
\end{lstlisting}

\begin{exmp}
After a union of 0 and 1, the data structure from Example \ref{empty_ufe} looks as follows:
\begin{lstlisting}
⦇uf_list = [1, 1, 2, 3], unions = [(0, 1)], au = [Some 0, None, None, None]⦈
\end{lstlisting}
There is an edge between 1 and 0, labeled with the union at index 0, which is $(0,1)$.
\end{exmp}

Next, we define a function which takes a list of unions as parameter and simply applies each of those unions to the data structure. This will be needed for the invariant and the correctness proof in the next sections.

\begin{lstlisting}
fun apply_unions :: "(nat * nat) list ⇒ ufe_data_structure ⇒ ufe_data_structure"
  where
    "apply_unions [] p = p" |
    "apply_unions ((x, y) # u) p = apply_unions u (ufe_union p x y)"
\end{lstlisting}

\subsection{Helper Functions for Explain}

The explain function is based on other functions, which will be described in the following pages.

\subsubsection{path\_to\_root}

The function \lstinline{path_to_root l x} computes the path from the root of $x$ to the node $x$ in the union-find forest l. It simply starts at $x$ and continues to add the parent of the current node to the path, until it reaches the root.

\begin{lstlisting}
function path_to_root :: "nat list ⇒ nat ⇒ nat list"
  where
    "path_to_root l x = (if l ! x = x then [x] else path_to_root l (l ! x) @ [x])"
  by pat_completeness auto
\end{lstlisting}

It was easy to show that it has the same domain as the \lstinline{rep_of} function, as it has the same recursive calls.

\begin{lstlisting}
lemma path_to_root_domain: "rep_of_dom (l, i) ⟷ path_to_root_dom (l, i)"
\end{lstlisting}

The correctness of the function follows easily by induction.

\begin{lstlisting}
theorem path_to_root_correct:
assumes "ufa_invar l"
shows "path l (rep_of l x) (path_to_root l x) x"
\end{lstlisting}

\subsubsection{lowest\_common\_ancestor}

The function \lstinline{lowest_common_ancestor l x y} finds the lowest common ancestor of $x$ and $y$ in the union-find forest $l$.

\begin{definition}
	A \emph{common ancestor} of two nodes $x$ and $y$ is a node which has a path to $x$ and a path to $y$.
	The \emph{lowest common ancestor} of two nodes $x$ and $y$ is a node common ancestor where its path to the root has maximal length.
\end{definition}

The function will only be used for two nodes which have the same root, otherwise there is no common ancestor. It first computes the paths from $x$ and $y$ to their root, and then returns the last element which the two paths have in common. For this it uses the function \lstinline{longest_common_prefix} from HOL-Library.Sublist\cite{Sublist}.

\begin{lstlisting}
fun lowest_common_ancestor :: "nat list ⇒ nat ⇒ nat ⇒ nat"
  where
    "lowest_common_ancestor l x y =
last (longest_common_prefix (path_to_root l x) (path_to_root l y))"
\end{lstlisting}

Regarding the correctness proof, there were two aspects to prove: the most useful result is that \lstinline{lowest_common_ancestor l x y} is a common ancestor of $x$ and $y$. The second aspect stated that any other common ancestor of $x$ and $y$ has a shorter distance from the root. The proof assumes that that $x$ and $y$ have the same root.

\begin{proof}
Let $lca =$\lstinline{lowest_common_ancestor l x y}. We previously proved that \lstinline{path_to_root} computes a path $p_x$ from the root to $x$ and a path $p_y$ from the root to $y$. Evidently, $lca$ lies on both paths, because it is part of their common prefix. Splitting the paths, we get a path from the root to $lca$ and one from $lca$ to $x$, and the same for $y$. This shows that $lca$ is a common ancestor.

To prove that it is the \emph{lowest} common ancestor, we can prove it by contradiction. If there was a common ancestor $lca_2$ with a longer path from the root than $lca$, then we can show that there is a path from the root to $x$ passing through $lca_2$, and the same for $y$. Because of the uniqueness of paths, these paths are equal to \lstinline{path_to_root l x} and \lstinline{path_to_root l y}, respectively. That means, that there is a prefix of \lstinline{path_to_root l x} and \lstinline{path_to_root l y} which is longer than the one calculated by the function \lstinline{longest_common_prefix}. The theory Sublist\cite{Sublist} contains a correctness proof for \lstinline{longest_common_prefix}, which we can use to show the contradiction.
\end{proof}

\subsubsection{find\_newest\_on\_path}

The function \lstinline{find_newest_on_path} finds the newest edge on the path from $y$ to $x$. It is assumed that $y$ is an ancestor of $x$. The function simply checks all the elements on the path from $y$ to $x$ and returns the one with the largest index in a, which represents the associated unions list.

\begin{lstlisting}
function (domintros) find_newest_on_path :: "nat list ⇒ nat option list ⇒ nat ⇒ nat ⇒ nat option"
where
"find_newest_on_path l a x y =
(if x = y then None
else max (a ! x) (find_newest_on_path l a (l ! x) y))"
by pat_completeness auto
\end{lstlisting}

If there is a path $p$ from $y$ to $x$, it is easily shown by induction that the function terminates.

\begin{lstlisting}
lemma find_newest_on_path_domain:
assumes "ufa_invar l"
and "path l y p x"
shows "find_newest_on_path_dom (l, a, x, y)"
\end{lstlisting}

For the correctness proof we define an abstract definition of the newest element on the path: \lstinline{Newest_on_path} is the maximal value in the associated unions list for indexes in $p$.

\begin{lstlisting}
abbreviation "Newest_on_path l a x y newest ≡
∃ p . path l y p x ∧ newest = (MAX i ∈ set [1..<length p]. a ! (p ! i))"
\end{lstlisting}

Then it can easily be shown by computation induction on \lstinline{find_newest_on_path} that our function is correct.

\begin{lstlisting}
theorem find_newest_on_path_correct:
assumes "path l y p x"
and "ufa_invar l"
and "x ≠ y"
shows "Newest_on_path l a x y (find_newest_on_path l a x y)"
\end{lstlisting}

\subsection{Explain}

We implement the explain function following the description of the first version of the union-find algorithm in the paper\cite{Nieuwenhuis}.

The explain function takes as parameter two elements $x$ and $y$ and calculates a subset of the input unions which explain why the two given variables are in the same equivalence class. If we consider the graph which has as nodes the elements and as edges the input unions, then the output of explain would be all the unions on the path from $x$ to $y$. However, the union-find forest in our data structure does not have as edges the unions, but only edges between representatives of the elements of the unions.

From this graph, we can calculate the desired output in the following way: first add the last union $(a, b)$ made between the equivalence class of $x$ and the one of $y$, then recursively call the explain operation with the new parameters $(x, a)$ and $(b, y)$ (or $(x, b)$ and $(a, y)$, depending on which branch $a$ and $b$ are on). The newst union is the label of the newest edge in the union-find forest.

$(a, b)$ is calculated by finding the lowest common ancestor $lca$ of $x$ and $y$, and then finding the newest union on the path from $x$ to $lca$ and from $y$ to $lca$. There is a case distinction at the end to account for the cases that the newest union is on same branch as $x$ or as $y$.

TODO example

\begin{lstlisting}
function (domintros) explain :: "ufe_data_structure ⇒ nat ⇒ nat ⇒ (nat * nat) set"
where
"explain ⦇uf_list = l, unions = u, au = a⦈ x y =
(if x = y ∨ rep_of l x ≠ rep_of l y then {}
else
(let lca = lowest_common_ancestor l x y;
newest_index_x = find_newest_on_path l a x lca;
newest_index_y = find_newest_on_path l a y lca;
(ax, bx) = u ! the (newest_index_x);
(ay, by) = u ! the (newest_index_y)
in
(if newest_index_x ≥ newest_index_y then
{(ax, bx)} ∪ explain ⦇uf_list = l, unions = u, au = a⦈ x ax
∪ explain ⦇uf_list = l, unions = u, au = a⦈ bx y
else
{(ay, by)} ∪ explain ⦇uf_list = l, unions = u, au = a⦈ x by
∪ explain ⦇uf_list = l, unions = u, au = a⦈ ay y)
)
)"
by pat_completeness auto
\end{lstlisting}

\section{Proofs}

This section introduces an invariant for the union find data structure and proves that the .\lstinline{explain} function terminates and is correct, when invoked with valid parameters.

\subsection{Invariant and Induction Rule}

The validity invariant of the data structure expresses that the data structure derived from subsequent unions with \lstinline{ufe_union}, starting from the initial empty data structure.
It also states that the unions were made with valid variables, i.e. varibles which are in bounds.

\begin{lstlisting}
abbreviation "ufe_invar ufe ≡
valid_unions (unions ufe) (length (uf_list ufe)) ∧
apply_unions (unions ufe) (initial_ufe (length (uf_list ufe))) = ufe"
\end{lstlisting}

With this definition, it is easy to show that the invariant holds after a union.

\begin{lstlisting}
lemma union_ufe_invar:
assumes "ufe_invar ufe"
shows "ufe_invar (ufe_union ufe x y)"
\end{lstlisting}

It is also useful to prove that the old invariant, \lstinline{ufa_invar}, is implied by the new invariant, so that we can use all the previously proved lemmas about \lstinline{ufa_invar}. This is easily shown by computation induction on the function \lstinline{apply_unions}, and by using the lemma from the Theory Union Find\cite{Sep}, which states that \lstinline{ufa_invar} holds after having applied \lstinline{ufa_union}, and proving that it holds for the initial ufe.

\begin{lstlisting}
theorem ufe_invar_imp_ufa_invar: "ufe_invar ufe ⟹ ufa_invar (uf_list ufe)"
\end{lstlisting}

With this definition of the invariant, we can prove a new induction rule, which will be very useful for proving many properties of a union find data structure. The induction rule, called \lstinline{apply_unions_induct}, has as an assumption that the invariant holds for the given data structure $ufe$, and shows that a certain predicate holds for $ufe$. The base case that needs to be proven is that it holds for the initial data structure, and the induction step is that the property remains invariant after applying a union.

\begin{lstlisting}
lemma apply_unions_induct[consumes 1, case_names initial union]:
assumes "ufe_invar ufe"
assumes "P (initial_ufe (length (uf_list ufe)))"
assumes "&$\bigwedge$&pufe x y. ufe_invar pufe ⟹ x < length (uf_list pufe) ⟹ y < length (uf_list pufe) ⟹ P pufe ⟹ P (ufe_union pufe x y)"
shows "P ufe"
\end{lstlisting}

This induction rule can be used for most of the proofs about explain.

\subsection{Termination Proof}
\label{subsection:termination}

An important result was to show that the function always terminates if \lstinline{ufe_invar} holds.

\begin{lstlisting}
theorem explain_domain:
assumes "ufe_invar ufe"
shows "explain_dom (ufe, x, y)"
\end{lstlisting}

\begin{proof}
For the base case, we consider the empty data structure. There are no different variables with the same representative, therefore the algorithm terminates immediately.

For the induction step we need to show that if the function terminates for a data structure $ufe$, then it also terminates for \lstinline{ufe_union ufe x y}.
The lowest common ancestor and the newest index on path do not change after a union was applied. Therefore the entire algorithm is executed with exactly the same results at each intermediate step, therefore the recursive calls are equal, and they terminate by induction hypothesis.
TODO
\end{proof}

\subsection{Correctness Proof}
TODO
There are two properties which define the correctness of explain: foremost, the equivalence closure of \lstinline{explain x y} should contain the pair $(x, y)$ (we shall refer to this property as "correctness"), additionally, the elements in the output should only be equations which are part of the input (we shall refer to this property as "validity"). The proposition about the validity of \lstinline{explain} looks as follows:

\begin{lstlisting}
theorem explain_valid:
assumes "ufe_invar ufe"
and "xy ∈ (explain ufe x y)"
shows "xy ∈ set (unions ufe)"
\end{lstlisting}

We know from Subsection \ref{subsection:termination} that when the invariant holds, the function terminates. Therefore we can use the partial induction rule that Isabelle automatically generates for partial functions. We can prove that $(a, b)$ is a valid union, given that it is in the \lstinline{unions} list, for that we need to prove that the index found by \lstinline{find_nearest_on_path} is in bounds.

\begin{lstlisting}
lemma find_newest_on_path_Some:
assumes "path l y p x"
and "ufe_invar ⦇uf_list = l, unions = u, au = a⦈"
and "x ≠ y"
obtains k where "find_newest_on_path l a x y = Some k ∧ k < length u"
\end{lstlisting}

which follows from the following lemma, that shows that the entries in the associated union list are valid, aka less than the length of u

\begin{lstlisting}
lemma au_valid:
assumes "ufe_invar ufe"
and "i < length (au ufe)"
shows "au ufe ! i < Some (length (unions ufe))"
\end{lstlisting}

It is easily proven, given that all the values that are added to au are valid.

Thus we have shown the validity of the explain function.
It remains to show the correctness.

\begin{lstlisting}[language=isabelle]
theorem explain_correct:
assumes "ufe_invar ufe"
and "rep_of (uf_list ufe) x = rep_of (uf_list ufe) y"
shows "(x, y) ∈ (symcl (explain ufe x y))*"
\end{lstlisting}

This was shown by computation induction on explain. For example for case x:
$(x, ax) \in$\lstinline{(explain x ax)*} and $(bx, y) \in\:$\lstinline{(explain bx y)*} and $(ax, bx) \in\:$\lstinline{explain x y}
Therefore $(x, y) \in\:$\lstinline{(explain x y)*}
