% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Union-Find with Explain Operation}\label{chapter:union_find}

\section{Union-Find Algorithm}
\label{section:uf-algorithm}

The union-find data structure is used to keep track of the equivalence closure of a set of equations between constants,  by partitioning the initial set of $n$ constants into equivalence classes. It is initialized with a partition where each element is in their own equivalence class. There is a \lstinline{union} operation which merges two equivalence classes. The \lstinline{find} operation returns a representative of the equivalence class. Two elements are in the same representative class, if and only if they have the same representative.

The equivalence classes are modeled with a forest, which is a graph where each connected component is a tree. Initially, the graph contains $n$ vertices and no edges, then each \lstinline{union} adds a directed edge. The connected components of the graph represent the equivalence classes. Each tree in the forest has a root, which is also the representative of the equivalence class, and each edge in the tree is directed towards the root. In order to keep this invariant, at each \lstinline{union a b}, the new edge is added between the representative of $a$ (which will be denoted as $rep\_of(l, a)$, where $l$ is the union-find forest) and $rep\_of(l, b)$.

The union-find forest is modeled by a list $l$ of length $n$, where at each index $i$ the list contains the parent of the element $i$ in the forest. If $i$ does not have a parent, i.e., it is a root, then the list contains the element $i$ itself at the index $i$, e.g. $l!i = i$.

The original union-find algorithm \cite{Tarjan} contains two tions: path compression in the \lstinline{find} method, and choosing the representative of the bigger class to be the new representative of the merged class in \lstinline{union}. These optimizations are irrelevant for the correctness of the algorithm, therefore we leave them out of this implementation in order to simplify the proofs.


\section{Union-Find in Isabelle}
\label{section:uf-isabelle}

The union-find algorithm was already formalized in Isabelle by Lammich \cite{unionfind-isabelle}, and the code can be found in the ``Archive of Formal Proofs'' (AFP) under ``A Separation Logic Framework for Imperative HOL'', in the theory ``Union\_Find''\cite{afp, Sep}. The following is a brief description of the implementation.

The function \lstinline{rep_of} finds the representative of an element in the forest. It is analogous to the \lstinline{find} operation, except that it does not do path compression.

\begin{lstlisting}
function (domintros) rep_of
  where "rep_of l i = (if l!i = i then i else rep_of l (l!i))"
  by pat_completeness auto
\end{lstlisting}

The domain of \lstinline{rep_of} is used to define the following invariant for valid union-find lists. This invariant states that the \lstinline{rep_of} function terminates on all valid indexes of the list, which is equivalent to saying that the union-find forest does not contain any cycles.

\begin{lstlisting}
definition
  "ufa_invar l ≡ ∀i<length l. rep_of_dom (l,i) ∧ l!i<length l"
\end{lstlisting}

The \lstinline{union} operation simply adds an edge between the representatives of the two elements.

\begin{lstlisting}
abbreviation "ufa_union l x y ≡ l[rep_of l x := rep_of l y]"
\end{lstlisting}

The theory contains several lemmas, including the lemma which states that the invariant \lstinline{ufa_invar} holds for the initial union-find forest without edges, and that it is preserved by the \lstinline{ufa_union} operation.

\section{Union-Find Data Structure}
\label{section:uf-data}

The section below describes the implementation of a union-find data structure, which was modified in order to support an \lstinline{explain} operation, as described in \cite{Nieuwenhuis}.

The data structure for the Union, Find and Explain operations consists of the following three lists:

\begin{itemize}
	\item \lstinline{uf_list}: This is the usual union-find list, which contains the parent node of each element in the forest data structure. It is the one described in Section \ref{section:uf-algorithm}.

	\item \lstinline{unions}: This list simply contains all the pairs of input elements in chronological order.

	\item \lstinline{au}: This is the \emph{associated unions} list, it contains for each edge in the union-find forest a label with the union that corresponds to this edge. Similarly to the \lstinline{uf_list}, it is indexed by the element, and for each element $e$ which has a parent in the \lstinline{uf_list}, \lstinline{au} contains the input equation which caused the creation of this edge between $e$ and its parent. The equations are represented as indexes in the \lstinline{unions} list. The type of the entries is \lstinline{nat option}, so that for elements without a parent, the \lstinline{au} entry is \lstinline{None}.
\end{itemize}

\begin{exmp}\label{empty_ufe}
For a union-find algorithm with 4 variables, the initial empty union find looks as follows:
\begin{lstlisting}
⦇uf_list = [0, 1, 2, 3], unions = [], au = [None, None, None, None]⦈
\end{lstlisting}
Each element is its own parent in the \lstinline{uf_list}, which means that it is a root, the \lstinline{unions} list is empty because no unions were made yet, and there are no edges in the tree, therefore there are no labels in \lstinline{au}.
\end{exmp}

In order to reason about paths in the union-find forest, we define the following \lstinline{path} predicate.

\begin{lstlisting}
inductive path :: "nat list ⇒ nat ⇒ nat list ⇒ nat ⇒ bool" where
  single: "n < length l ⟹ path l n [n] n" |
  step: "r < length l ⟹ l ! u = r ⟹ l ! u ≠ u ⟹  path l u p v ⟹ path l r (r # p) v"
\end{lstlisting}

\lstinline{path l r p v} defines a path from $r$ to $v$, where $r$ is an ancestor of $v$, which means that it is closer to the root, and $p$ is a list which contains all the nodes visited on the path from $r$ to $v$. This definition proved to be very useful for many proofs, as will become clearer later in this thesis.

The theory ``Path'' contains many lemmas about paths, including lemmas about concatenation of adjacent paths, and splitting of one path into two subpaths, and that the length of a path is at least 1, as well as others, many of which could be proven by rule induction on \lstinline{path}. The most interesting and useful lemma was about the uniqueness of paths between two nodes:

\begin{lstlisting}
theorem path_unique: "ufa_invar l ⟹ path l u p1 v ⟹ path l u p2 v ⟹ p1 = p2"
\end{lstlisting}

\begin{proof}
The lemma is proven by induction on the length of $p1$.

For the base case we assume that the length of $p1$ is 1. There is only one node in the path, therefore $v = u$. Then we prove a lemma which shows that if the \lstinline{ufa_invar} holds, each path from $v$ to $v$ has length 1, or, in other words, there are no cycles in the graph. For this we show that if there was a cycle, the function \lstinline{rep_of} would not terminate, because there would be an infinite loop.

For the induction step, we assume that the length of $p1$ is greater than 1. Therefore, we can remove the last node from $p1$ and the last node from $p2$ to get two paths $p1'$ and $p2'$ from $u$ to the parent of $v$, where $p1'$ is shorter that $p1$, and we can apply the induction hypothesis, which tells us that $p1' = p2'$. Adding the node $v$ to those two paths gives us back the original paths $p1$ and $p2$, therefore we conclude that $p1 = p2$.
\end{proof}

\section{Implementation}

\subsection{Union}

The \lstinline{ufa_union} operation needs to be extended in order to appropiately update the other two lists:

The function \lstinline{ufe_union} only modifies the data structure if the parameters are not already in the same equivalence class.
The \lstinline{uf_list} is modified with \lstinline{ufa_union}.
The current union $(x, y)$ is appended to the end of the \lstinline{unions} list.
\lstinline{au} is updated such that the new edge between \lstinline{rep_of l x} and \lstinline{rep_of l y} is labeled with the last index of \lstinline{unions}, which contains the current pair of elements $(x, y)$.

\begin{lstlisting}
fun ufe_union :: "ufe_data_structure ⇒ nat ⇒ nat ⇒ ufe_data_structure"
  where
    "ufe_union ⦇uf_list = l, unions = u, au = a⦈ x y = (
if (rep_of l x ≠ rep_of l y) then
    ⦇uf_list = ufa_union l x y,
     unions = u @ [(x,y)],
     au = a[rep_of l x := Some (length u)]⦈
else ⦇uf_list = l, unions = u, au = a⦈)"
\end{lstlisting}

\begin{exmp}
After a union of 1 and 0, the data structure from Example \ref{empty_ufe} looks as follows:
\begin{lstlisting}
⦇uf_list = [0, 0, 2, 3], unions = [(1, 0)], au = [None, Some 0, None, None]⦈
\end{lstlisting}
It has the following graphical representation:
0 $\xleftarrow{\text{(1, 0)}}$ 1 \ \ 2 \ \ 3
\end{exmp}

Next, we define a function which takes a list of unions as parameter and simply applies each of those unions to the data structure. This will be needed for the invariant and the correctness proof in the next sections.

\begin{lstlisting}
fun apply_unions :: "(nat * nat) list ⇒ ufe_data_structure ⇒ ufe_data_structure"
  where
    "apply_unions [] p = p" |
    "apply_unions ((x, y) # u) p = apply_unions u (ufe_union p x y)"
\end{lstlisting}

\begin{exmp}\label{example:apply-unions}
The result of \lstinline|apply_unions [(1,0), (3,2), (3,1)] (initial_ufe 4)|, where \lstinline|initial_ufe n| is the empty union-find list with $n$ variables, looks like this:

3 $\xrightarrow{\text{(3, 2)}}$ 2$\xrightarrow{\text{(3, 1)}}$ 0 $\xleftarrow{\text{(1, 0)}}$ 1 \
\end{exmp}

\subsection{Helper Functions for Explain}

We implement the explain function following the description of the first version of the union-find algorithm in the paper \cite{Nieuwenhuis}.

The explain function takes as parameter two elements $x$ and $y$ and calculates a subset of the input unions which explain why the two given variables are in the same equivalence class. If we consider the graph which has as nodes the elements and as edges the input unions, then the output of explain would be all the unions on the path from $x$ to $y$. However, the union-find forest in our data structure does not have as edges the unions, but only edges between representatives of the elements of the unions.

From this graph, we can calculate the desired output in the following way: first add the last union $(a, b)$ made between the equivalence class of $x$ and the one of $y$, then recursively call the explain operation with the new parameters $(x, a)$ and $(b, y)$ (or $(x, b)$ and $(a, y)$, depending on which branch $a$ and $b$ are on). The last union is the edge with the highest label in the union-find forest.

$(a, b)$ is calculated by finding the lowest common ancestor $lca$ of $x$ and $y$, and then finding the newest union on the path from $x$ to $lca$ and from $y$ to $lca$.

This section describes the helper functions needed for the implementation of \lstinline|explain|, which calculate the lowest common ancestor, using the function \lstinline{path_to_root}, and the newest union on a path.

\subsubsection{path\_to\_root}
\label{subsubsection:path-to-root}

The function \lstinline{path_to_root l x} computes the path from the root of $x$ to the node $x$ in the union-find forest $l$. It simply starts at $x$ and continues to add the parent of the current node to the front of the path, until it reaches the root.

\begin{lstlisting}
function path_to_root :: "nat list ⇒ nat ⇒ nat list"
  where
    "path_to_root l x = (if l ! x = x then [x] else path_to_root l (l ! x) @ [x])"
  by pat_completeness auto
\end{lstlisting}

\begin{exmp}
If we consider $l$ to be the union-find list of Example \ref{example:apply-unions},

\lstinline|path_to_root l 3 = [0, 2, 3]|.
\end{exmp}

It was easy to show that it has the same domain as the \lstinline{rep_of} function, as it has the same recursive calls.

\begin{lstlisting}
lemma path_to_root_domain: "rep_of_dom (l, i) ⟷ path_to_root_dom (l, i)"
\end{lstlisting}

The correctness of the function follows easily by computation induction.

\begin{lstlisting}
theorem path_to_root_correct:
  assumes "ufa_invar l"
  shows "path l (rep_of l x) (path_to_root l x) x"
\end{lstlisting}

\subsubsection{lowest\_common\_ancestor}

The function \lstinline{lowest_common_ancestor l x y} finds the lowest common ancestor of $x$ and $y$ in the union-find forest $l$.

\begin{definition}
A \emph{common ancestor} of two nodes $x$ and $y$ is a node which has a path to $x$ and a path to $y$.
The \emph{lowest common ancestor} of two nodes $x$ and $y$ is the common ancestor which is farthest away from the root.
\end{definition}

The function will only be used for two nodes which have the same root, otherwise there is no common ancestor. It first computes the paths from $x$ and $y$ to their root, and then returns the last element which the two paths have in common. For this it uses the function \lstinline{longest_common_prefix} from ``HOL-Library.Sublist'', which is included in the standard Isabelle distribution.

\begin{lstlisting}
fun lowest_common_ancestor :: "nat list ⇒ nat ⇒ nat ⇒ nat"
  where
    "lowest_common_ancestor l x y =
last (longest_common_prefix (path_to_root l x) (path_to_root l y))"
\end{lstlisting}

\begin{exmp}
If we consider $l$ to be the union-find list of Example \ref{example:apply-unions},

\lstinline|lowest_common_ancestor l 3 1 = 0|.
\end{exmp}

Regarding the correctness proof, there were two aspects to prove: the most useful result is that \lstinline{lowest_common_ancestor l x y} is a common ancestor of $x$ and $y$. The second aspect stated that any other common ancestor of $x$ and $y$ has a shorter distance from the root. The proof assumes that that $x$ and $y$ have the same root.

\begin{lstlisting}
abbreviation "common_ancestor l x y ca ≡
(∃ p . path l ca p x) ∧
(∃ p . path l ca p y)"

abbreviation "Lowest_common_ancestor l x y ca ≡
(common_ancestor l x y ca ∧
(∀r ca2 p3 p4. (path l r p3 ca ∧ path l r p4 ca2 ∧ common_ancestor l x y ca2
⟶ length p3 ≥ length p4)))"

theorem lowest_common_ancestor_correct:
  assumes "ufa_invar l"
    and "x < length l"
    and "y < length l"
    and "rep_of l x = rep_of l y"
  shows "Lowest_common_ancestor l x y (lowest_common_ancestor l x y)"
\end{lstlisting}

\begin{proof}
Let $lca =$\lstinline{lowest_common_ancestor l x y}. We previously proved that \lstinline{path_to_root} computes a path $p_x$ from the root to $x$ and a path $p_y$ from the root to $y$. Evidently, $lca$ lies on both paths, because it is part of their common prefix. Splitting the path $p_x$, we get a path from the root to $lca$ and one from $lca$ to $x$, and the same for $y$. This shows that $lca$ is a common ancestor.

To prove that it is the \emph{lowest} common ancestor, we can prove it by contradiction. We assume that there is a common ancestor $lca_2$ with a longer path from the root than $lca$, then we can show that there is a path from the root to $x$ passing through $lca_2$, and the same for $y$. Because of the uniqueness of paths, these paths are equal to \lstinline{path_to_root l x} and \lstinline{path_to_root l y}, respectively. That means, that there is a prefix of \lstinline{path_to_root l x} and \lstinline{path_to_root l y} which is longer than the one calculated by the function \lstinline{longest_common_prefix}. The theory ``Sublist'' contains a correctness proof for \lstinline{longest_common_prefix}, which we can use to show the contradiction.
\end{proof}

\subsubsection{find\_newest\_on\_path}

The function \lstinline{find_newest_on_path} finds the newest edge on the path from $y$ to $x$. It is assumed that $y$ is an ancestor of $x$. The function simply checks all the elements on the path from $y$ to $x$ and returns the one with the largest index in a, which is the \emph{associated unions} list.

\begin{lstlisting}
function (domintros) find_newest_on_path  :: "nat list ⇒ nat option list ⇒ nat ⇒ nat ⇒ nat option"
  where
    "find_newest_on_path l a x y =
  (if x = y then None
    else max (a ! x) (find_newest_on_path l a (l ! x) y))"
  by pat_completeness auto
\end{lstlisting}

\begin{exmp}
Let $l$ be the union-find list of Example \ref{example:apply-unions}, if we consider the edge labels in the associated unions list, instead of the unions they represent, the union-find graph looks like this:

3 $\xrightarrow{\text{1}}$ 2$\xrightarrow{\text{2}}$ 0 $\xleftarrow{\text{0}}$ 1 \

From this representation we can see that the newest index on the path from 3 to 0 is 2.
\end{exmp}

If there is a path $p$ from $y$ to $x$, it is easily shown by induction that the function terminates.

\begin{lstlisting}
lemma find_newest_on_path_domain:
  assumes "ufa_invar l"
    and "path l y p x"
  shows "find_newest_on_path_dom (l, a, x, y)"
\end{lstlisting}

Note that some additional assumptions of the type \lstinline|"x < length l"| are in the original formulation of this lemma. The assumption that all the variables are in bounds is present in all the lemmas about union-find and congruence closure, but they will not be mentioned in the thesis for reasons of conciseness. For the exact formulation of the lemmas, see the Isabelle code.

For the correctness proof we define an abstract definition of the newest element on the path: \lstinline{Newest_on_path} is the maximal value in the associated unions list for indexes in $p$.

\begin{lstlisting}
abbreviation "Newest_on_path l a x y newest ≡
∃ p . path l y p x ∧ newest = (MAX i ∈ set [1..<length p]. a ! (p ! i))"
\end{lstlisting}

Then it can easily be shown by computation induction on \lstinline{find_newest_on_path} that our function is correct.

\begin{lstlisting}
theorem find_newest_on_path_correct:
  assumes path: "path l y p x"
    and invar: "ufa_invar l"
    and xy: "x ≠ y"
  shows "Newest_on_path l a x y (find_newest_on_path l a x y)"
\end{lstlisting}

\subsection{Explain}

We can now define the explain operation, as describbed in the previous Subsection.
In order to find the overall newest edge, we first compute the newest edge on the $x$ branch, then the one on the $y$ branch, and then choose the larger one in a case distinction at the end.

\begin{lstlisting}
function (domintros) explain :: "ufe_data_structure ⇒ nat ⇒ nat ⇒ (nat * nat) set"
  where
    "explain ⦇uf_list = l, unions = u, au = a⦈ x y =
      (if x = y ∨ rep_of l x ≠ rep_of l y then {}
      else
          (let lca = lowest_common_ancestor l x y;
           newest_index_x = find_newest_on_path l a x lca;
           newest_index_y = find_newest_on_path l a y lca;
           (a$_x$, b$_x$) = u ! the (newest_index_x);
           (a$_y$, b$_y$) = u ! the (newest_index_y)
        in
        (if newest_index_x ≥ newest_index_y then
          {(a$_x$, b$_x$)} ∪ explain ⦇uf_list = l, unions = u, au = a⦈ x a$_x$
            ∪ explain ⦇uf_list = l, unions = u, au = a⦈ b$_x$ y
        else
          {(a$_y$, b$_y$)} ∪ explain ⦇uf_list = l, unions = u, au = a⦈ x b$_y$
            ∪ explain ⦇uf_list = l, unions = u, au = a⦈ a$_y$ y))
)"
  by pat_completeness auto
\end{lstlisting}

\begin{exmp}
Let $ufe$ be the union-find data structure of Example \ref{example:apply-unions}. We compute the output of \lstinline|explain ufe 3 1|

We already saw in the previous examples that \lstinline|lca = 0|, \lstinline|newest_index_x = 2|
and it is easy to see that \lstinline|newest_index_x ≥ newest_index_y|. The list of unions is \lstinline|[(1,0), (3,2), (3,1)]|, therefore \lstinline|a$_x$ = 3| and \lstinline|b$_x$ = 1|. The two recursive calls terminate immediately, hence \lstinline|explain ufe 3 1 = {(3, 1)}|.
\end{exmp}

\section{Proofs}

This section introduces an invariant for the union find data structure and proves that the \lstinline{explain} function terminates and is correct, when invoked with valid parameters.

\subsection{Invariant and Induction Rule}

The validity invariant of the data structure expresses that the data structure derived from subsequent unions with \lstinline{ufe_union}, starting from the initial empty data structure.
It also states that the unions were made with valid variables, i.e., variables which are in bounds.

\begin{lstlisting}
abbreviation "ufe_invar ufe ≡
  valid_unions (unions ufe) (length (uf_list ufe)) ∧
  apply_unions (unions ufe) (initial_ufe (length (uf_list ufe))) = ufe"
\end{lstlisting}

With this definition, it is easy to show that the invariant holds after a union.

\begin{lstlisting}
lemma union_ufe_invar:
  assumes "ufe_invar ufe"
  shows "ufe_invar (ufe_union ufe x y)"
\end{lstlisting}

It is also useful to prove that the old invariant, \lstinline{ufa_invar}, is implied by the new invariant, so that we can use all the previously proved lemmas about \lstinline{ufa_invar}. This is easily shown by computation induction on the function \lstinline{apply_unions}, and by using the lemma from the Theory ``Union Find'', which states that \lstinline{ufa_invar} holds after having applied \lstinline{ufa_union}, and by proving that it holds for the initial empty data structure.

\begin{lstlisting}
theorem ufe_invar_imp_ufa_invar: "ufe_invar ufe ⟹ ufa_invar (uf_list ufe)"
\end{lstlisting}

With this definition of the invariant, we can prove a new induction rule, which will be very useful for proving many properties of a union-find data structure. The induction rule, called \lstinline{apply_unions_induct}, has as an assumption that the invariant holds for the given data structure $ufe$, and shows that a certain predicate holds for $ufe$. The base case that needs to be proven is that it holds for the initial data structure, and the induction step is that the property remains invariant after applying a union.

\begin{lstlisting}
lemma apply_unions_induct[consumes 1, case_names initial union]:
  assumes "ufe_invar ufe"
  assumes "P (initial_ufe (length (uf_list ufe)))"
  assumes "⋀pufe x y. ufe_invar pufe ⟹ x < length (uf_list pufe) ⟹ y < length (uf_list pufe)
    ⟹ P pufe ⟹ P (ufe_union pufe x y)"
  shows "P ufe"
\end{lstlisting}

This induction rule can be used for most of the proofs about explain.

\subsection{Termination Proof}
\label{subsection:termination}

An important result was to show that the function always terminates if \lstinline{ufe_invar} holds. We will show this using \lstinline|apply_unions_invar|, therefore we need to show that if the function terminates before \lstinline{ufe_union} is applied, then it also terminates afterwards, assuming that $x$ and $y$ are in the same representative class, where $x$ and $y$ are the last two parameters of explain.

\begin{lstlisting}
lemma explain_domain_ufe_union_invar:
  assumes "explain_dom (ufe, x, y)"
    and "ufe_invar ufe"
    and "rep_of (uf_list ufe) x = rep_of (uf_list ufe) y"
  shows "explain_dom (ufe_union ufe x2 y2, x, y)"
\end{lstlisting}

\begin{proof}
We can use the partial induction rule of \lstinline|explain|, given that our first assumption is that explain terminates.

We show only the case when \lstinline|newest_index_x ≥ newest_index_y|, because the other case is symmetric to it. The Isabelle code also contains proofs about the symmetry of \lstinline{explain}, which are used in order to avoid duplicate proofs for the two cases of the \lstinline{explain} function, but they will not be discussed here, as they are not essential to prove the correctness of the function.

Initially, we remark that the lowest common ancestor and the newest index on path do not change after a union was applied. Therefore we will refer to the variables with the same names as in the function definition, e.g. $lca$, $ax$, etc., without specifying if we refer to e.g. \lstinline|lowest_common_ancestor l x y| or \lstinline|lowest_common_ancestor (ufa_union l x2 y2) $\:\:$x y|.

We assume that $x$ and $y$ are in the same representative class after the union. Given that $(ax, bx)$ is the newest branch on the path fom $ax$ to the lowest common ancestor $lca$ of $x$ and $y$, we know that every edge on the path from $x$ to $ax$ was also present before the union. Therefore $rep\_of(l, ax) = rep\_of(l, x)$ holds before the union, and we can apply the induction hypothesis and conclude \lstinline|explain_dom(ufe_union ufe x2 y2, x, ax)|. $(ax, bx)$ is also newer than the newest branch on the path fom $y$ to the $lca$, therefore $rep\_of(l, y) = rep\_of(l, bx)$, and the induction hypothesis shows that \lstinline|explain_dom(ufe_union ufe x2 y2, bx, y)|. The two recursive calls terminate, therefore \lstinline|explain| terminates.
\end{proof}

Using this result we can prove the termination of \lstinline|explain|:

\begin{lstlisting}
theorem explain_domain:
  assumes "ufe_invar ufe"
  shows "explain_dom (ufe, x, y)"
\end{lstlisting}

\begin{proof}
We prove it by using \lstinline|apply_union_induct|.

For the base case, we consider the empty data structure. There are no distinct variables with the same representative, therefore the algorithm terminates immediately.

For the induction step, if $x$ and $y$ are not in the same representative class after the union, the function terminates immediately. Otherwise, we can show that $x$ and $ax$ are in the same representative class before the union, and $bx$ and $y$ as well, therefore we can apply the previous lemma to the recursive calls of the function, and conclude that \lstinline|explain| terminates.
\end{proof}

\subsection{Correctness Proof}

There are two properties which define the correctness of explain: foremost, the equivalence closure of \lstinline{explain x y} should contain the pair $(x, y)$ (we shall refer to this property as ``correctness''), additionally, the elements in the output should only be equations which are part of the input (we shall refer to this property as ``validity''). The proposition about the validity of \lstinline{explain} is the following:

\begin{lstlisting}
theorem explain_valid:
  assumes "ufe_invar ufe"
    and "k ∈ (explain ufe x y)"
  shows "k ∈ set (unions ufe)"
\end{lstlisting}

We know from Subsection \ref{subsection:termination} that when the invariant holds, the function terminates. Therefore we can use the partial induction rule for \lstinline|explain| that Isabelle automatically generates for partial functions. We can prove that $k$ is a valid union, given that each element in \lstinline|explain ufe x y| originally derives from the \lstinline{unions} list, which is the list of input equations. In order to use this argument, we need to prove that the index found by \lstinline{find_nearest_on_path} is in bounds.

\begin{lstlisting}
lemma find_newest_on_path_Some:
  assumes "path l y p x"
    and "ufe_invar ⦇uf_list = l, unions = un, au = a⦈"
    and "x ≠ y"
  obtains k where "find_newest_on_path l a x y = Some k ∧ k < length un"
\end{lstlisting}

This follows from the following lemma, that shows that the entries in the \emph{associated unions} list are in bounds.

\begin{lstlisting}
lemma au_valid:
  assumes "ufe_invar ufe"
    and "i < length (au ufe)"
  shows "au ufe ! i < Some (length (unions ufe))"
\end{lstlisting}

It is easily proven, given that all the values that are added to \lstinline|au| by \lstinline|ufe_union| are valid.

Thus we can prove the lemma about the validity of the explain function.
It remains to show the correctness.

\begin{lstlisting}
theorem explain_correct:
  assumes "ufe_invar ufe"
    and "rep_of (uf_list ufe) x = rep_of (uf_list ufe) y"
  shows "(x, y) ∈ (symcl (explain ufe x y))*"
\end{lstlisting}

\begin{proof}
This was shown using the induction rule of \lstinline|explain|.

For the case where \lstinline|x = y|, the algorithm returns the empty set, and because of reflexivity $(x, y)$ is in the equivalence closure of the empty set.

As before, for the remaining cases we consider only the case where \lstinline|newest_index_x ≥ newest_index_y|.
From the induction hypothesis, we know that $(x, ax) \in$\lstinline{(symcl (explain ufe x y))*} and $(bx, y) \in\:$\lstinline{(symcl (explain ufe x y))*}.

Because of the definition of explain, it holds that $(ax, bx) \in\:$\lstinline{(explain x y)}. Therefore from the transitivity of the equivalence closure it follows that $(x, y) \in\:$\lstinline{(symcl (explain ufe x y))*}.
\end{proof}
