\documentclass[
  sigplan,
  10pt,
  anonymous,
  review,
  ]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}

\usepackage[british]{babel}

\usepackage[capitalise]{cleveref}

\usepackage{mathpartir}

% Record brackets
\usepackage{stmaryrd}

\usepackage{xcolor}

\usepackage{tikz}
\usepackage{pgfplots}

\usepackage{enumitem}

\usepackage{array}
\usepackage{multirow}

\usepackage[acronym]{glossaries}
\newacronym{adt}{ADT}{Abstract Data Type}
\newacronym{uf}{UF}{Union-Find}
\newacronym{ufe}{UFE}{Union-Find-Explain}

\usepackage{listings}
\definecolor{isarblue}{HTML}{006699}
\definecolor{isargreen}{HTML}{009966}
\lstdefinelanguage{isabelle}{%
    keywords=[1]{type_synonym,typedef,datatype,fun,function,abbreviation,definition,proof,lemma,theorem,corollary,inductive},
    keywordstyle=[1]\bfseries\color{isarblue},
    keywords=[2]{where,assumes,shows,and,fixes,defines},
    keywordstyle=[2]\bfseries\color{isargreen},
    keywords=[3]{if,then,else,case,of,SOME,let,in,O},
    keywordstyle=[3]\color{isarblue},
}
\lstset{%
  language=isabelle,
  escapeinside={&}{&},
  columns=\lst@ifdisplaystyle{fullflexible}\else{fixed}\fi,,
  extendedchars,
  basewidth={0.5em,0.45em},
  basicstyle=\ttfamily,
  mathescape,
}
\makeatletter
\lst@AddToHook{OnEmptyLine}{\vspace{-0.4\baselineskip}}
\makeatother
\newcommand{\lstinlinew}[2][]{\lstinline[#1]{#2}}
% This is a hack to allow escaping inside lstinline (https://tex.stackexchange.com/questions/43526/escaping-in-lstinline)
\usepackage{etoolbox}
\makeatletter
\patchcmd{\lsthk@TextStyle}{\let\lst@DefEsc\@empty}{}{}{\errmessage{failed to patch}}
\makeatother

\usepackage{calc}

\newcommand{\textover}[3][l]{%
 % #1 is the alignment, default l
 % #2 is the text to be printed
 % #3 is the text for setting the width
 \makebox[\widthof{#3}][#1]{#2}%
}

\hyphenation{Isa-belle}

% For arXiv: LuaLatex on Arxiv: https://tex.stackexchange.com/questions/372154/lualatex-how-to-produce-pdf-acceptable-by-arxiv 
%\hypersetup{%
%  pdfcreator = {},
%  pdfproducer = {}
%}
%\pdfvariable suppressoptionalinfo \numexpr 1+2+4+8+16+32+64+128+256+512 \relax

% For arXiv: Remove copyright information
% \setcopyright{none}
% \renewcommand\footnotetextcopyrightpermission[1]{}


\usepackage{todonotes}

% Autoref names
\renewcommand{\sectionautorefname}{Section}
\renewcommand{\subsectionautorefname}{Section}

% Notation
\newcommand{\TransP}{\bigtriangledown}

\begin{document}

% For arXiv: Remove conference/author in the header
% \pagestyle{plain}

\setcounter{tocdepth}{1}

\title{Simplified and Verified: A Fresh Look at a Proof-Producing Union-Find Algorithm}
\author{Lukas Stevens}
\orcid{0000-0003-0222-6858}
\affiliation{%
  \institution{Technical University of Munich}
  \department{Department of Informatics}
  \streetaddress{Boltzmannstr. 3}
  \city{Garching}
  \postcode{85748}
  \country{Germany}
}
\email{lukas.stevens@in.tum.de}

\begin{abstract}
  TODO
\end{abstract}

\maketitle

\listoftodos{}

\section{Introduction}
\begin{itemize}
  \item Based on \cite{congcl_proofs}
\end{itemize}
\subsection{Contributions}

\subsection{Related Work}
\begin{itemize}
  \item Congruence closure in Coq by Corbineau
\end{itemize}


\subsection{Notation}
Isabelle/HOL~\cite{isabelle} conforms to everyday mathematical notation for the most part.
We establish notation and in particular some essential data types together with their primitive operations that are specific to Isabelle/HOL.

We write \lstinline!t :: 'a! to specify that the term \lstinline!t! has the type \lstinline!'a! and \lstinline!'a $\Rightarrow$ 'b! for the space of total functions from type \lstinline!'a! to type \lstinline!'b!.

Sets with elements of type \lstinline!'a! have the type \lstinline!'a set!.
The cardinality of a set \lstinline!A! is denoted by \lstinline!card A! and the image of \lstinline!A! under \lstinline!f! by \lstinline!f ` A!.

We use \lstinline!'a list! to describe the type of lists, which are constructed using the empty list \lstinline![]! constructor or the infix cons constructor \lstinline!#!, and are appended with the infix operator \lstinline!@!.
The function \lstinline!set! converts a list into a set.
\todo[inline]{Indexing operator}
\todo[inline]{Relation type synonym, Field of a relation}
\todo[inline]{Record notation}

We remark that $\longleftrightarrow$ is equivalent to \lstinline!$=$! on the type of Booleans \lstinline!bool! and \lstinline!$\equiv$! is definitional equality of the meta-logic of Isabelle/HOL, which is called Isabelle/Pure.
Meta-implication is denoted by \lstinline!$\Longrightarrow$! and a chain of implications
\begin{lstlisting}
  A$_\text{1}$ $\Longrightarrow$ $\cdots$ $\Longrightarrow$ A$_\text{k}$ $\Longrightarrow$ C
\end{lstlisting}
can be abbreviated by 
\begin{lstlisting}
  $\llbracket$ A$_\text{1}$;$\,\ldots\,$;A$_\text{k}$ $\rrbracket$ $\Longrightarrow$ C.
\end{lstlisting}

\section{Basic Union-Find}
\subsection{Background\label{sec:uf_background}}
Given a set of $n$ elements $A = \{a_1, \ldots, a_n\}$, the \acrfull{uf} data structure keeps track of a partition of $A$ into disjoint sets $A_1, \ldots, A_k$, i.e.\ $A = A_1 \uplus \cdots \uplus A_k$.

We initialise the data structure by partitioning $A$ into singleton sets of elements,
so we have that $A = \{a_1\} \uplus \cdots \uplus \{a_n\}$.
Those sets are merged by subsequent \lstinline!union! operations\todo{use italics for union operation?} where \lstinline!union $a_i$ $a_j$! merges the set containing $a_i$ with the one that contains $a_j$.
Each set in the partition contains one particular element that serves as its representative.
We will denote the representative of an element $a$ in the \acrshort{uf} data structure $l$ as \lstinline!rep_of $l$ $a$!.
Accordingly, two elements have the same representative exactly when they belong to the same set in the partition.
For any element $a_i$, the \lstinline!find! operation just returns its representative \lstinline!rep_of $l$ $a_i$!.

One application of this algorithm is to maintain the equivalence closure of equations, which is the partial equivalence relation formed by those equations.
To this end, we initialize the \acrshort{uf} data structure with $n$ elements for a given set of variables $v_1, \ldots, v_n$ and perform a \lstinline!union! between $v_i$ and $v_j$ for each equation $v_i = v_j$.
This results in a partition of the variables into equivalence classes.

According to \citeauthor{unionfind_tarjan}~\cite{unionfind_tarjan}, this data structure can be implemented as a forest of rooted trees where each tree represents an equivalence class.
The edges of the trees are directed towards their root, which is the representative of the corresponding equivalence class.
To keep this invariant, we initialise the forest with $n$ nodes but without any edges and for every \lstinline!union! of $a_i$ and $a_j$ we add a directed edge from \lstinline!rep_of $l$ $a_i$! to \lstinline!rep_of $l$ $a_j$! to the forest.

We encode such a forest as a list $l$ of length $n$, where at each index $i$ of the list, we save the parent of the element $i$.
Therefore, we denote the parent of an element $a$ with \lstinline|$l$ ! $a$|.
If $a$ is a root and thus does not have a parent, then the list contains the element $a$ itself at the index $a$, i.e., \lstinline|$l$ ! $a$ = $a$|.

\todo[inline]{Mention optimisations?}

\subsection{In Isabelle/HOL}
The \acrshort{uf} algorithm is formalised in Isabelle/HOL by \citeauthor{unionfind_isabelle}~\cite{unionfind_isabelle}.
The code can be found in an entry~\cite{union_find_afp} of the \emph{Archive of Formal Proofs} (AFP).\footnote{The code is in the theory file \texttt{Examples/Union\_Find.thy}.}
Later, \citeauthor{union_find_imp_hol}~\cite{union_find_imp_hol} also formalised the running time.\todo{Check citations}

The formalisation defines a function \lstinline|rep_of|, which, as described in the previous section, follows the parent pointers until we arrive the root, where the parent pointer is self-referential.
\begin{lstlisting}[columns=fullflexible]
function rep_of :: nat list $\Rightarrow$ nat $\Rightarrow$ nat where
rep_of l a =
  if l ! a = a then a else rep_of l (l ! a)
\end{lstlisting}
Looking closely at this definition, we see that this function is only well-defined for some inputs \lstinline|l| and \lstinline|a|:
for every element \lstinline|a < length l|, its parent must be in the list, i.e.\ we must have \lstinline|l ! a < length l|, and the parent pointers must be cycle-free in order for the function to terminate.
Functions in Isabelle/HOL must be total, so the \lstinline|function| command introduces a constant
\begin{lstlisting}
rep_of_dom :: (nat list $\times$ nat) $\Rightarrow$ bool  
\end{lstlisting}
that characterises the inputs for which \lstinline|rep_of| terminates.
Then, it adds \lstinline|rep_of_dom (l, a)| as a premise to the defining equation of \lstinline|rep_of|. 
The intuition above is cast into a predicate \lstinline|ufa_invar| that defines such well-formed lists \lstinline|l|.
\begin{lstlisting}
ufa_invar l = $\forall$a < length l. rep_of_dom (l, a)
              $\land$ l ! a < length l
\end{lstlisting}

Building on this formalisation, we encapsulate this \acrshort{uf} data structure into an \acrfull{adt} \lstinline|ufa| by defining
\begin{lstlisting}
typedef ufa = {uf. ufa_invar uf}
\end{lstlisting}
By lifting operations on the underlying list to the \acrshort{adt} using Isabelle's lifting infrastructure~\cite{lifting_transfer}, we obtain the operations
\begin{itemize}
  \item \lstinline!ufa_$\alpha$ :: ufa $\Rightarrow$ nat rel!,
  \item \lstinline!ufa_rep_of :: ufa $\Rightarrow$ nat $\Rightarrow$ nat!, and
  \item \lstinline!ufa_union :: ufa $\Rightarrow$ nat $\Rightarrow$ nat $\Rightarrow$ ufa!,
\end{itemize}
where \lstinline!nat rel = (nat $\times$ nat) set!.
The intended meaning of these operations is the following:
\begin{itemize}
  \item \lstinline!ufa_$\alpha$ uf! is the partial equivalence relation represented by \lstinline!uf!,
  \item \lstinline!ufa_rep_of uf x! is the representative of the equivalence class that \lstinline!x! belongs to, and
  \item \lstinline!ufa_union uf x y! returns a \acrshort{uf} data structure where the equivalence classes of \lstinline!x! and \lstinline!y! are merged.
    This is implemented by updating the underlying list at index \lstinline!rep_of l x! with \lstinline|rep_of l y|.
\end{itemize}
More rigorously, the above operations fulfil the following properties:\todo{Spacing between lemmas,defs}
\begin{lstlisting}
lemma ufa_rep_of uf x = ufa_rep_of uf y $\longleftrightarrow$
  (x, y) $\in$ ufa_$\alpha$ uf

lemma ufa_$\alpha$ (ufa_union uf x y) =
  per_union (ufa_$\alpha$ uf) x y
\end{lstlisting}
where \lstinline!per_union R x y!\todo{Definition with \lstinline|trancl|?} is defined as the equivalence relation that results from merging the respective equivalence classes in the relation \lstinline|R| that \lstinline!x! and \lstinline!y! belong to.

But what happens if \lstinline!x! or \lstinline!y! is not an element of the partial equivalence relation \lstinline|R|?\todo{Define element of per.}
In that case, the equivalence relation is unchanged, which means that \lstinline|per_union R x y = R|.
This, however, can be seen as a misuse of the \acrshort{uf} data structure, since we initialise it with a fixed set of elements \lstinline|A| and expect the user to only work with these elements.
Therefore, we introduce the following definitions that characterise valid union(s) with regard to the initial set \lstinline|A|.
\begin{lstlisting}
definition valid_union uf a b =
  a $\in$ Field (ufa_$\alpha$ uf) $\land$ b $\in$ Field (ufa_$\alpha$ uf)
definition valid_unions uf us =
  $\forall$(x, y) $\in$ set us. valid_union uf x y
\end{lstlisting}

\section{Simple Certifying Union-Find Algorithm}
\begin{figure}
  \begin{gather*}
    \inferrule*[right=Assm]{\hbox{\lstinline|i < length us|} \\ \hbox{\lstinline|us ! i = (x, y)|}}{\hbox{\lstinline|us $\ \vdash_=\ $ AssmP i : (x, y)|}} \\[0.5em]
    \inferrule*[right=Refl]{ }{\hbox{\lstinline|us $\ \vdash_=\ $ ReflP x : (x, x)|}} \\[0.5em]
    \inferrule*[right=Sym]{\hbox{\lstinline|us $\ \vdash_=\ $ p : (x, y)|}}{\hbox{\lstinline|us $\ \vdash_=\ $ SymP p : (y, x)|}} \\[0.5em]
    \inferrule*[right=Trans]{\hbox{\lstinline|us $\ \vdash_=\ $ p1 : (x, y)|} \\ \hbox{\lstinline|us $\ \vdash_=\ $ p2 (y, z)|}}{\hbox{\lstinline|us $\ \vdash_=\ $ p1 $\ \TransP\ $ p2 : (x, z)|}}
  \end{gather*}
  \caption{The data type \lstinline|eq_prf| of certificates and its corresponding system of inference rules $\vdash_=$.\label{fig:eq_prf}}
\end{figure}
Building on the \acrshort{uf} \acrshort{adt} from the previous section, we now develop a simple \lstinline|explain| operation that,
for a given list of equations \lstinline|us|, takes two elements \lstinline|x| and \lstinline|y| and produces a certificate that \lstinline|x = y| modulo \lstinline|us|.
The certificate is given in terms of a data type \lstinline|eq_prf| with its corresponding system $\vdash_=$ of inference rules as seen in \autoref{fig:eq_prf}.
As expected, we have inference rules that utilise the reflexivity, symmetry, and transitivity of equality as well as an assumption rule.
To improve readability, we use the infix operator $\bigtriangledown$ to denote the proof term for transitivity.

We remark that one can not prove disequality with this proof system.
In that sense, we are working with an open-world assumption. 

We prove that $\vdash_=$ is sound and complete with respect to the equivalence relation induced by \lstinline|us|, i.e.\ the equivalence closure of \lstinline|us|.
In Isabelle, we define\todo{Introduce inverse and rtrancl?}
\begin{lstlisting}
definition symcl r = r $\cup$ r$^{-1}$
definition equivcl r = (symcl r)$^*$
\end{lstlisting}
and prove
\begin{lstlisting}
lemma $\vdash_=$_sound:
assumes as $\vdash_=$ p : (x, y)
shows (x, y) $\in$ equivcl (set as)

lemma $\vdash_=$_complete:
assumes (x, y) $\in$ equivcl (set as)
shows $\exists$p. as $\vdash_=$ p : (x, y)
\end{lstlisting}

\begin{figure*}
  \centering
  \begin{lstlisting}
function explain :: (nat $\times$ nat) list $\Rightarrow$ nat $\Rightarrow$ nat $\Rightarrow$ nat eq_prf where
  explain [] x _ = ReflP x
| explain (us @ [(a, b)]) x y =
    let uf = ufa_unions uf_init us; a_b_P = AssmP (length us)
    in if ufa_rep_of uf x = ufa_rep_of uf y then explain us x y
      else if ufa_rep_of uf x = ufa_rep_of uf a then explain us x a $\TransP$ a_b_P $\TransP$ explain us y b
      else explain us x b $\TransP$ SymP a_b_P $\TransP$ explain us a y

definition explain_partial us x y =
  if (x, y) $\in$ equivcl (set us) then Some (explain us x y) else None
  \end{lstlisting}
  \caption{A simple implementation of the \lstinline|explain| operation. It operates on an arbitrary initial \acrshort{uf} data structure \lstinline|uf_init|.\label{fig:explain}}
\end{figure*}
Although \lstinline|explain| takes a list of equations \lstinline|us|, its implementation actually works with an instance \lstinline|uf| of the \acrshort{uf} \acrshort{adt} that results from applying \lstinline|us| as unions to an initial \acrshort{uf} data structure \lstinline|uf_init|.
Accordingly, we define
\begin{lstlisting}
definition ufa_unions =
  foldl ($\lambda$uf (x, y). ufa_union uf x y)
\end{lstlisting}
so we have \lstinline|uf = ufa_unions uf_init us| in terms of the constants above.

At last, we are ready to implement the \lstinline|explain| operation as depicted in \autoref{fig:explain}.\todo{explain with Cons instead of snoc}
The algorithm works with the assumption that the given elements \lstinline|x| and \lstinline|y| are equal modulo \lstinline|us|.
Furthermore, we assume that each element of the initial data structure \lstinline|uf_init| is equal to itself
and that \lstinline|us| are valid unions with respect to \lstinline|uf_init|.
In formulae, we assume
\begin{itemize}
  \item \lstinline|ufa_$\alpha$ uf_init $\subseteq$ Id|, and
  \item \lstinline|valid_unions uf_init us|
\end{itemize}
in what follows.

If the list of unions is empty, then \lstinline|x| and \lstinline|y| must actually be equal which we certify with \lstinline|ReflP x|.

Otherwise, the list of unions must be equal to \lstinline|us @ [(a, b)]| for some \lstinline|us|, \lstinline|a|, and \lstinline|b|.
We distinguish between two cases:
\begin{itemize}
  \item The elements \lstinline|x| and \lstinline|y| are already equal modulo \lstinline|us|, so we proceed recursively with \lstinline|us|.
  \item In the case that the equation \lstinline|a = b| is necessary for \lstinline|x = y| to hold, we either have \lstinline|x = a| and \lstinline|b = y| or \lstinline|x = b| and \lstinline|a = y| modulo \lstinline|us|.
    Assuming that the former holds --- the other case is similar --- we recursively construct the certificates for \lstinline|x = a| and \lstinline|b = y|.
    Together with the fact that \lstinline|a = b|, which we prove by assumption, we obtain \lstinline|x = y| by transitivity.
\end{itemize}

We condense the above intuition into the completeness theorem below.
\begin{lstlisting}
theorem explain_complete:
assumes (x, y) $\in$ equivcl (set us)
shows us $\vdash_=$ explain uf_init us x y : (x, y)
\end{lstlisting}

The \lstinline|explain| function is not sound, though.
This is because it always returns a certificate, even if \lstinline|x| and \lstinline|y| are not equal modulo \lstinline|us|.
To account for this case, we wrap \lstinline|explain| into a partial function \lstinline|explain_partial| (cf.\ \autoref{fig:explain}) that fails if \lstinline|x = y| is not provable.
Soundness and completeness can then be lifted from the soundness of $\vdash_=$ and the completeness of \lstinline|explain|, respectively.
At first glance, it might seem vacuous to define \lstinline|explain_partial| using \lstinline|equivcl|;
however, \lstinline|equivcl| can actually be implemented using \acrshort{uf} operations as the following lemma demonstrates.
\begin{lstlisting}
lemma
defines uf = ufa_unions uf_init us
shows (x, y) $\in$ equivcl (set us) $\leftrightarrow$ x = y $\lor$
  x $\in$ Field (ufa_$\alpha$ uf) $\land$ y $\in$ Field (ufa_$\alpha$ uf) $\land$
  ufa_rep_of uf x = ufa_rep_of uf y
\end{lstlisting}
\todo[inline]{Improve explanation above? Segue?}

\section{Efficient Certifying Union-Find Algorithm}
In the previous section, we developed a simple certifying \acrfull{ufe} data structure whose \lstinline|explain| operation iterates through a list of equalities,
identifying which of them are necessary in order to prove that its input values are equal.
Nevertheless, iterating through all equalities seems to be inefficient and indeed \citeauthor{congcl_proofs}~\cite{congcl_proofs} propose a more targeted approach.
Their approach adds two data structures to the list of equalities, which we collect into a record type \lstinline|ufe_ds|.
We call this collection of data structures the \acrshort{ufe} data structure.
For some fixed instance \lstinline|ufe_ds|, the purpose of the record members is as follows:
\todo[inline]{Introduce \lstinline|ufa_parent_of|, explain abstraction leakage. intuition here?. Name for the union-find-explain data structure?}
\begin{itemize}
  \item The list \lstinline|unions ufe_ds :: (nat $\times$ nat) list| contains the input equalities.
  \item The \acrshort{ufe} data structure \lstinline|uf_ds ufe_ds :: ufa| maintains the equivalence closure of the input equalities or, put differently, it is the result of applying \lstinline|unions ufe_ds| to an initial union find data structure.
    We require this to be a forest of rooted trees as introduced in \autoref{sec:uf_background}.
  \item The partial function \lstinline|au_ds ufe_ds :: nat $\Rightarrow$ nat option| associates an unique equality with each edge in the forest by indexing into \lstinline|unions ufe_ds|.
    In other words, there exists an \lstinline|i| such that \lstinline|au_ds ufe_ds x $\neq$ Some i| if \lstinline|x| has a parent in the forest.
    The associated union of the edge from \lstinline|x| to its parent is then \lstinline|unions ufe_ds ! i|.
\end{itemize}
For succinctness, we lift the operations \lstinline|ufa_rep_of|, \lstinline|ufa_parent_of|, and \lstinline|ufa_$\alpha$|\todo{Introduce \lstinline|ufa_parent_of|} from the record member \lstinline|uf_ds| to the record type \lstinline|ufe_ds|.
The lifted operations use the prefix \lstinline|ufe| instead of \lstinline|ufa|, so \lstinline|ufa_rep_of| is lifted to \lstinline|ufe_rep_of|, for example.

Similarly, we obtain the initial \acrshort{ufe} data structure by lifting \lstinline|ufa_init| while leaving the other two members empty as the following definition shows.
\todo[inline]{Introduce \lstinline|ufa_init|}
\begin{lstlisting}
definition ufe_init :: nat $\Rightarrow$ ufe_ds where
  ufe_init n = $\llparenthesis$ uf_ds = ufa_init n,
    au_ds = ($\lambda$_. None), unions = [] $\rrparenthesis$
\end{lstlisting}
Continuing with the union operation, we lift \lstinline|ufa_union| to the \acrshort{ufe} data structure.
For a union operation between \lstinline|x| and \lstinline|y|, we add \lstinline|(x, y)| to the list of unions and update the associated union of the representative of \lstinline|x| to \lstinline|(x, y)|.
We need to use the representative here because \lstinline|ufa_union| adds an edge from the representative of \lstinline|x| to that of \lstinline|y|.
As with the \acrshort{uf} data structure, we also define a function that applies a list of unions in consecutive order.
\begin{lstlisting}
fun ufe_union :: ufe_ds $\Rightarrow$ nat $\Rightarrow$ nat
              $\Rightarrow$ ufe_ds where
  ufe_union $\llparenthesis$ uf_ds = uf
            , au_ds = au, unions = u $\rrparenthesis$ x y =
    $\llparenthesis$ uf_ds = ufa_union uf x y
    , au_ds = au(ufa_rep_of uf x $\mapsto$ length u)
    , unions = u @ [(x, y)] $\rrparenthesis$

definition ufe_unions = 
  foldl ($\lambda$ufe_ds (x, y). ufe_union ufe_ds x y)
\end{lstlisting}
However, there is a catch in the definition of \lstinline|ufe_union|:
specifically, it only makes sense to update the (associated) unions if the union in question actually introduces a new edge in the \acrshort{uf} data structure.
In other words, the representatives of \lstinline|x| and \lstinline|y| of the union \lstinline|(x, y)| must not be equal.
We call such a union \emph{effective} with respect to a given \acrshort{uf} data structure.
This notion extends to lists of unions by checking if each consecutive union is effective with respect to the data structure that results from applying the preceeding unions.
\begin{lstlisting}
definition eff_union uf a b =
  valid_union uf a b $\land$
  ufa_rep_of uf a $\neq$ ufa_rep_of uf b

fun eff_unions where
  eff_unions uf [] $\leftrightarrow$ True
| eff_unions uf ((a, b) # us) $\leftrightarrow$
    eff_union uf a b $\land$
    eff_unions (ufa_union uf a b) us
\end{lstlisting}
\todo[inline]{\lstinline|ufe_lca|}

\begin{figure*}
  \centering
  \begin{lstlisting}
definition combine_options where
  combine_options f x y =
    case x of None $\Rightarrow$ y | Some x $\Rightarrow$ (case y of None $\Rightarrow$ Some x | Some y $\Rightarrow$ Some (f x y))

function find_newest_on_path where
  find_newest_on_path y x =
    if x = y then None
    else combine_options max (au_ds ufe_ds x) (find_newest_on_path y (ufe_parent_of ufe_ds x))

function explain' :: nat $\Rightarrow$ nat $\Rightarrow$ nat eq_prf where
  explain' x y =
    if x = y then ReflP x
    else
      let
        lca = ufe_lca ufe_ds x y;
        newest_x = find_newest_on_path lca x;
        newest_y = find_newest_on_path lca y
      in
        if newest_y $\leq$ newest_x then
          let (ax, bx) = unions ufe_ds ! the newest_x
          in explain' x ax $\TransP$ AssmP (the newest_x) $\TransP$ explain' bx y
        else
          let (ay, by) = unions ufe_ds ! the newest_y
          in explain' x by $\TransP$ SymP (AssmP (the newest_y)) $\TransP$ explain' ay y
  \end{lstlisting}
  \caption{Efficient version of \lstinline|explain|. The above functions work on a fixed \acrshort{ufe} data structure \lstinline|ufe_ds|.}
\end{figure*}

  
We define a locale \lstinline|ufe_init_invars| that fixes an initial data structure \lstinline|ufe_init| and assumes
\begin{itemize}
  \item \lstinline|ufe_$\alpha$ ufe_init $\subseteq$ Id|,
  \item \lstinline|au_ds ufe_init = ($\lambda$_. None)|,
  \item \lstinline|unions ufe_init = []|.
\end{itemize}
We extend this locale in order to describe well-formed such data structures which are exactly does that arise from applying a sequence of unions to a well-formed initial data structure.
More specifically, we fix a data structure \lstinline|ufe_ds| and assume
\begin{itemize}
  \item \lstinline|eff_unions (uf_ds ufe_init) (unions ufe_ds)|,
  \item \lstinline|ufe_ds = ufe_unions ufe_init (unions ufe_ds)|.
\end{itemize}
We assume 
\begin{itemize}
  \item \lstinline|x,$\,$y $\in$ Field (ufe_$\alpha$ ufe_ds)| and
  \item \lstinline|ufe_rep_of ufe_ds x = ufe_rep_of ufe_ds y|.
\end{itemize}

\begin{lstlisting}
lemma explain'_dom_ufe_union:
assumes explain_dom' ufe_ds (x, y)
assumes eff_union (uf_ds ufe_ds) a b
shows explain'_dom (ufe_union ufe_ds a b) (x, y)
\end{lstlisting}

\begin{lstlisting}
lemma explain'_dom_if_ufe_rep_of_eq:
shows explain'_dom ufe_ds (x, y)
\end{lstlisting}

\begin{lstlisting}
lemma explain'_ufe_union:
assumes eff_union (uf_ds ufe_ds) a b
shows explain' (ufe_union ufe_ds a b) x y =
  explain' ufe_ds x y
\end{lstlisting}

\begin{lstlisting}
lemma explain_eq_explain':
shows explain (uf_ds ufe_init) (unions ufe_ds x y) =
  explain' ufe_ds x y
\end{lstlisting}
  
\begin{itemize}
  \item Abbreviations
  \item \lstinline|awalk_verts_from_rep|
  \item \lstinline|ufa_lca|
  \item \lstinline|find_newest_on_path|
  \item \lstinline|explain'|. Figure with schematic tree.
  \item locales: \lstinline|ufe_invars|, \lstinline|ufa_tree|, \lstinline|ufe_tree|
  \item \lstinline|awalk_from_rep_ufa_union|, \lstinline|ufa_lca_ufa_union|, \lstinline|find_newest_on_path_ufe_union|
  \item \lstinline|ufe_ds_induct|
  \item Invariance of helper functions if rep already equal before union
  \item Union by rank
\end{itemize}

\section{Deriving an Efficient Implementation}

\begin{itemize}
  \item Inspired by formalisation by Lammich~\cite{unionfind_isabelle}, in AFP~\cite{union_find_afp}
  \item Refinements with ranks and int ranks
\end{itemize}

\begin{itemize}
  \item Refinements with ranks and ints
  \item Helper Functions
  \item Locales
  \item Induction principle and code equation
\end{itemize}

\section{Refinement to Imperative HOL}
\begin{itemize}
  \item Refining ufri
  \item Dynamic Array inspired by Auto2 Imperative HOL
  \item Refining explain operations
  \item Union-by-rank also checks whether the union is effective
\end{itemize}

\section{Tactic}
Proof of concept tactic

\section{Conclusion and Future Work}

\begin{acks}
  TODO
\end{acks}

\printglossary[type=\acronymtype]

\bibliographystyle{ACM-Reference-Format}
\bibliography{sources}

\end{document}
